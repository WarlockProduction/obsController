<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Consolas", monospace;
            font-size: .5rem;
            color: #ddd;
            scrollbar-color: #3c3c3c #1c1c1c;
            scrollbar-width: thin;
        }

        body {
            background-color: #1c1c1c;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        div.containImg {
            width: 100%;
            display: flex;
            justify-content: center;
        }

        img {
            width: 100%;
            max-width: 200px;
            height: auto;
            margin-bottom: 20px;
            border-radius: 8px;
            border: 1px solid #333;
            box-shadow: 0 0 10px #000;
            filter: blur(.5rem) brightness(0);
            transition: .7s;
        }

        img.hover:hover {
            filter: blur(0) brightness(1);
        }

        input[type="text"],
        input[type="password"],
        select,
        option {
            width: 100%;
            max-width: 400px;
            padding: 12px 16px;
            margin: 5px 0;
            background-color: #2e2e2e;
            border: 1px solid #555;
            border-radius: 8px;
            color: #eee;
            font-size: 1.2rem;
            transition: border-color 0.3s, box-shadow 0.3s;
            outline: none;
        }

        input[type="text"]:focus,
        input[type="password"]:focus,
        select:focus,
        option:focus {
            border-color: #284cb8;
            /* Bleu OBS */
            box-shadow: 0 0 8px #284cb8;
            background-color: #3b3b3b;
        }

        input[type="text"].error,
        input[type="password"].error,
        select.error,
        option.error {
            background-color: #881111;
        }

        button {
            width: 100%;
            max-width: 400px;
            padding: 14px 0;
            margin: 5px 0;
            background-color: #3b3b3b;
            border: none;
            border-radius: 1000px;
            color: #ddd;
            font-size: 1.2rem;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            -webkit-user-select: none;
            user-select: none;
            box-shadow: inset 0 -3px 0 #222;
        }

        button:hover {
            background-color: #284cb8;
            box-shadow: 0 0 12px #284cb8;
            color: #fff;
        }

        button:active {
            background-color: #4b6a99;
            box-shadow: inset 0 3px 5px #2e3a5a;
        }

        #password,
        #passwordHide {
            width: 100%;
            max-width: 400px;
            margin: 10px auto;
            padding: 12px;
            border-radius: 12px;
            text-align: center;
            font-size: 1.5rem;
            background-color: #2e2e2e;
            border: 1px solid #555;
            color: #eee;
            -webkit-user-select: all;
            user-select: all;
            box-shadow: inset 0 0 5px #000;
        }

        #password {
            letter-spacing: .1em;
        }

        #connectedView,
        #disconnectedView {
            width: 100%;
            max-width: 440px;
            background-color: #252525;
            padding: 30px 20px;
            border-radius: 16px;
            box-shadow: 0 0 20px #000 inset;
            overflow: hidden;
        }

        p {
            color: #ccc;
            margin: 10px 0;
        }

        hr {
            border-color: #ffffff44;
            margin: 20px 30%;
        }

        h1 {
            text-align: center;
            font-size: 1.5rem;
        }
    </style>
</head>

<body>
    <div id="connectedView" style="display: none;">
        <div class="containImg">
            <img src="qr.png" alt="">
        </div>

        <input type="text" name="userName" id="userName" placeholder="Votre pseudo">

        <p id="password" style="display: none;">abcd1234</p>
        <p id="passwordHide">******</p>
        <button id="passwordShowing" onclick="showPswd()">Show password</button>
        <button id="regenPswd" onclick="regenPswd()" style="display: none;">Regen password ?</button>

        <button onclick="refreshPage()">Refresh</button>
        <button onclick="copyCurrentUrlToClipboard()" style="display:none;">Copy current link</button>

        <hr>
        <h1>Backup config</h1>
        <select name="sources" id="sources"></select>
        <select name="scenes" id="scenes"></select>
        <select name="scenesLarix" id="scenesLarix"></select>
    </div>
    <div id="disconnectedView">
        <input type="text" name="portObs" id="portObs" placeholder="port of websocket in obs" value="4455">
        <input type="password" name="pswdObs" id="pswdObs" placeholder="mdp of websocket in obs">

        <button style="margin-top: 30px;" onclick="refreshPage()">Refresh</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script>
        const url = new URL(window.location.href);

        const element_connectedView = document.querySelector('div#connectedView')
        const element_disconnectedView = document.querySelector('div#disconnectedView')

        const element_passwordShowing = document.querySelector('button#passwordShowing')
        const element_regenPswd = document.querySelector('button#regenPswd')
        const element_password = document.querySelector('p#password')
        const element_passwordHide = document.querySelector('p#passwordHide')

        const element_userName = document.querySelector('input#userName')
        const element_portObs = document.querySelector('input#portObs')
        const element_pswdObs = document.querySelector('input#pswdObs')

        const element_images = [...document.querySelectorAll('img')]

        const protocols = ["obswebsocket.json"];

        var sources = [];
        var source;
        var scenes = [];
        var scene;
        var sceneLarix;
        var ProgramScene;
        var isOn = false;

        const element_sources = document.querySelector('select#sources')
        const element_scenes = document.querySelector('select#scenes')
        const element_scenesLarix = document.querySelector('select#scenesLarix')

        let obsSocket;
        let socket;
        let version;
        let obsReady = false;

        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789012345678901234567890123456789"
        function generateString(l) {
            var s = ''
            for (let i = 0; i < l; i++) {
                s += chars[Math.floor((chars.length * 0.999) * Math.random())]
            }
            return s;
        }

        function copyCurrentUrlToClipboard() {
            const currentUrl = window.location.href;
            navigator.clipboard.writeText(currentUrl)
                .then(() => {
                    console.log('URL copiée dans le presse-papier :', currentUrl);
                })
                .catch(err => {
                    console.error('Erreur lors de la copie :', err);
                });
        }

        function refreshPage() {
            window.location.reload();
        }

        var pswd = '';
        function regenPswd() {
            pswd = generateString(8)
            element_password.innerText = pswd
            url.searchParams.set('d', pswd);
            window.history.pushState({}, '', url);

            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            socket.send(JSON.stringify({
                w: {
                    Pseudo: element_userName.value,
                    Password: element_password.innerText,
                    OBSVersion: version
                }
            }))
        }

        element_images.forEach(img => {
            img.addEventListener('click', () => {
                img.classList.toggle('hover');
            })
            img.addEventListener('mouseover', () => {
                img.classList.remove('hover');
            })
        })


        element_sources.addEventListener('change', () => {
            url.searchParams.set('s', element_sources.value || undefined);
            window.history.pushState({}, '', url);
            source = element_sources.value;
        })
        if (url.searchParams.get('s')) source = url.searchParams.get('s');

        element_scenes.addEventListener('change', () => {
            url.searchParams.set('S', element_scenes.value || undefined);
            window.history.pushState({}, '', url);
            scene = element_scenes.value;
        })
        if (url.searchParams.get('S')) scene = url.searchParams.get('S');

        element_scenesLarix.addEventListener('change', () => {
            url.searchParams.set('Sl', element_scenesLarix.value || undefined);
            window.history.pushState({}, '', url);
            sceneLarix = element_scenesLarix.value;
        })
        if (url.searchParams.get('Sl')) sceneLarix = url.searchParams.get('Sl');

        element_userName.addEventListener('input', () => {
            url.searchParams.set('u', element_userName.value || undefined);
            window.history.pushState({}, '', url);
            if (!socket) return obsSocket ? connectServerWebSocket() : NaN;
            socket.send(JSON.stringify({
                w: {
                    Pseudo: element_userName.value,
                    Password: element_password.innerText,
                    OBSVersion: version
                }
            }))
        })
        if (url.searchParams.get('u')) element_userName.value = url.searchParams.get('u');

        element_pswdObs.addEventListener('input', () => {
            url.searchParams.set('p', element_pswdObs.value || undefined);
            window.history.pushState({}, '', url);
        })
        if (url.searchParams.get('p')) element_pswdObs.value = url.searchParams.get('p');

        if (url.searchParams.get('d')) element_password.innerText = url.searchParams.get('d');
        else regenPswd();

        var pswdIsShowed = false;
        function showPswd() {
            if (pswdIsShowed) {
                element_passwordShowing.style.display = ''
                element_regenPswd.style.display = 'none'
                element_password.style.display = 'none'
                element_passwordHide.style.display = ''
            } else {
                element_passwordShowing.style.display = 'none'
                element_regenPswd.style.display = ''
                element_password.style.display = ''
                element_passwordHide.style.display = 'none'
            }
            pswdIsShowed = !pswdIsShowed;
        }
        element_regenPswd.addEventListener('mouseout', () => {
            if (pswdIsShowed) showPswd();
        })

        var connectionStartedObs = false;
        function connectOBSWebSocket() {
            if (element_pswdObs.value === '') return
            if (connectionStartedObs) return;
            connectionStartedObs = true;
            if (obsSocket && obsSocket.close) obsSocket.close();
            obsReady = false;
            const me = new WebSocket("ws://localhost:" + element_portObs.value, protocols);
            obsSocket = me;

            me.onopen = () => {
                connectionStartedObs = false;
                console.log("Connecté à OBS WebSocket");
                setTimeout(() => {
                    if (obsSocket !== me) me.close(4999, 'duplication.')
                })
            };

            me.onmessage = (event) => {
                const response = JSON.parse(event.data);

                if (response.d && response.d.authentication) {
                    const { salt, challenge } = response.d.authentication;
                    const password = element_pswdObs.value || '1';

                    version = JSON.stringify({
                        op: 2,
                        d: {
                            obsWebSocketVersion: response.d.obsWebSocketVersion,
                            rpcVersion: response.d.rpcVersion
                        }
                    })

                    const secret = CryptoJS.SHA256(password + salt).toString(CryptoJS.enc.Base64);
                    const auth = CryptoJS.SHA256(secret + challenge).toString(CryptoJS.enc.Base64);

                    me.send(JSON.stringify({
                        op: 1,
                        d: {
                            rpcVersion: 1,
                            authentication: auth,
                            clientName: 'Accès via mobile (obs-web)'
                        }
                    }));
                    return;
                }

                element_connectedView.style.display = '';
                element_disconnectedView.style.display = 'none';
                if (response.d && response.d.obsWebSocketVersion) {
                    response.op = 2;
                    version = JSON.stringify(response);
                }

                if (response.op === 2) {
                    console.log("Authentifié à OBS WebSocket");
                    connectServerWebSocket();
                    obsReady = true;
                }

                if (response.d && response.d.requestId === "GetInputList-local" && response.d.requestType === "GetInputList") {
                    sources = response.d.responseData.inputs.filter(e => e.inputKind === "ffmpeg_source").sort((a, b) => a.inputName.localeCompare(b.inputName));
                    if (!source || !sources.find(e => e.inputUuid === source)) {
                        source = "";
                        url.searchParams.delete("s");
                        window.history.pushState({}, '', url);
                    }

                    element_sources.innerHTML = `
                        <option value="" disabled${source === "" ? ' selected' : ''}>Source a détecter:</option>
                        ${sources.map(e => `
                            <option value="${e.inputUuid}" ${e.inputUuid === source ? ' selected' : ''}>${e.inputName}</option>
                        `).join('')}
                    `

                    if (!scene || scene === "" || !source || source === "") return;

                    obsSocket.send(JSON.stringify({
                        op: 6,
                        d: {
                            requestId: "GetMediaInputStatus-local",
                            requestType: "GetMediaInputStatus",
                            requestData: {
                                inputUuid: source
                            }
                        }
                    }))

                    return
                }

                else if (response.d && response.d.requestId === "GetSceneList-local" && response.d.requestType === "GetSceneList") {
                    scenes = response.d.responseData.scenes.sort((a, b) => b.sceneIndex - a.sceneIndex);
                    ProgramScene = response.d.responseData.currentProgramSceneUuid;
                    if (!scene || !scenes.find(e => e.sceneUuid === scene)) {
                        scene = "";
                        url.searchParams.delete("S");
                        window.history.pushState({}, '', url);
                    }
                    if (!sceneLarix || !scenes.find(e => e.sceneUuid === sceneLarix)) {
                        sceneLarix = "";
                        url.searchParams.delete("Sl");
                        window.history.pushState({}, '', url);
                    }

                    element_scenes.innerHTML = `
                        <option value="" disabled${scene === "" ? ' selected' : ''}>Scène stream principal:</option>
                        ${scenes.map(e => `
                            <option value="${e.sceneUuid}" ${e.sceneUuid === scene ? ' selected' : ''}>${e.sceneName}</option>
                        `).join('')}
                    `

                    element_scenesLarix.innerHTML = `
                        <option value="" disabled${scene === "" ? ' selected' : ''}>Scène caméra téléphone:</option>
                        ${scenes.map(e => `
                            <option value="${e.sceneUuid}" ${e.sceneUuid === sceneLarix ? ' selected' : ''}>${e.sceneName}</option>
                        `).join('')}
                    `

                    return
                }

                else if (response.d && response.d.requestId === "GetMediaInputStatus-local" && response.d.requestType === "GetMediaInputStatus") {
                    const mediaStatus = response.d.responseData;

                    if (mediaStatus.mediaState === "OBS_MEDIA_STATE_PLAYING" && mediaStatus.mediaCursor !== 0) {
                        isOn = false;
                        if (ProgramScene === sceneLarix) return;
                        obsSocket.send(JSON.stringify({
                            op: 6,
                            d: {
                                requestId: "SetCurrentProgramScene-local",
                                requestType: "SetCurrentProgramScene",
                                requestData: {
                                    sceneUuid: sceneLarix
                                }
                            }
                        }))
                        return;
                    }

                    if (isOn) return;
                    isOn = true;
                    if (ProgramScene === scene) return;
                    obsSocket.send(JSON.stringify({
                        op: 6,
                        d: {
                            requestId: "SetCurrentProgramScene-local",
                            requestType: "SetCurrentProgramScene",
                            requestData: {
                                sceneUuid: scene
                            }
                        }
                    }))

                    return
                }

                if (!socket || socket.readyState !== WebSocket.OPEN) return;
                socket.send(JSON.stringify(response));
            };

            me.onerror = (error) => {
                console.error("Erreur WebSocket", error);
            };

            me.onclose = (event) => {
                console.warn(`WebSocket OBS fermé : code ${event.code}, raison : "${event.reason}"`);
                element_connectedView.style.display = 'none';
                element_disconnectedView.style.display = '';
                if (socket && socket.close) socket.close(4999, 'Die by obs closing');
                if (obsSocket === me && event.code !== 4009 && event.code !== 4999) setTimeout(() => connectOBSWebSocket(), 2_000)
                if (obsSocket === me) obsReady = false;
                if (obsSocket === me) obsSocket = undefined;
            };
        }

        var connectionStartedServer = false;
        function connectServerWebSocket() {
            if (connectionStartedServer) return;
            connectionStartedServer = true;
            if (socket && socket.close) socket.close();
            const currentUrl = new URL(url.href)
            currentUrl.pathname = '/client'
            currentUrl.search = "";
            currentUrl.protocol = currentUrl.protocol === 'https' ? 'wss' : 'ws'
            const me = new WebSocket(currentUrl, protocols);
            socket = me;

            me.onopen = () => {
                connectionStartedServer = false;
                element_userName.classList.remove('error');
                console.log("Connecté à server WebSocket")
                setTimeout(() => {
                    if (socket !== me) me.close(4999, 'duplication.')
                })

                me.send(JSON.stringify({
                    w: {
                        Pseudo: element_userName.value,
                        Password: element_password.innerText,
                        OBSVersion: version
                    }
                }))
            };

            me.onmessage = (event) => {
                const response = JSON.parse(event.data);

                if (!obsSocket || obsSocket.readyState !== WebSocket.OPEN || !obsReady) return;
                obsSocket.send(JSON.stringify(response))
            };

            me.onerror = (error) => {
                console.error("Erreur WebSocket", error);
            };

            me.onclose = (event) => {
                console.warn(`WebSocket server fermé : code ${event.code}, raison : "${event.reason}"`);
                if (socket === me && obsSocket && event.code !== 4009 && event.code !== 4999) setTimeout(() => connectServerWebSocket(), 2_000)
                if (socket === me) socket = undefined;
                else if (event.code === 4009) {
                    element_userName.classList.add('error');
                }
            };
        }

        connectOBSWebSocket();
        element_pswdObs.addEventListener('input', () => connectOBSWebSocket())

        setInterval(() => {
            if (!obsSocket || obsSocket.readyState !== WebSocket.OPEN || !obsReady) return;

            obsSocket.send(JSON.stringify({
                op: 6,
                d: {
                    requestId: "GetInputList-local",
                    requestType: "GetInputList",
                    requestData: {
                        inputKind: "ffmpeg_source"
                    }
                }
            }))

            obsSocket.send(JSON.stringify({
                op: 6,
                d: {
                    requestId: "GetSceneList-local",
                    requestType: "GetSceneList"
                }
            }))
        }, 250);
    </script>
</body>

</html>